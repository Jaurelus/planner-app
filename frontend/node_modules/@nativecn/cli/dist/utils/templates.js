"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getTemplateDir = getTemplateDir;
exports.getComponentDependencies = getComponentDependencies;
exports.resolveComponentDependencies = resolveComponentDependencies;
exports.copyComponentTemplate = copyComponentTemplate;
exports.generateComponentIndex = generateComponentIndex;
const path_1 = __importDefault(require("path"));
const chalk_1 = __importDefault(require("chalk"));
const fs_extra_1 = __importDefault(require("fs-extra"));
const config_1 = require("./config");
/**
 * Get the template directory for a component
 */
function getTemplateDir(component) {
    // Try multiple possible locations for component templates
    const possiblePaths = [
        // First check if there are templates within the CLI package
        path_1.default.resolve(__dirname, '../../templates', component),
        // Then check relative to the CLI package in a monorepo setup
        path_1.default.resolve(__dirname, '../../../components/ui', component),
        // Lastly, check relative to current directory for local development
        path_1.default.resolve(process.cwd(), 'components/ui', component),
    ];
    for (const templatePath of possiblePaths) {
        if (fs_extra_1.default.existsSync(templatePath)) {
            return templatePath;
        }
    }
    throw new Error(`Component template '${component}' not found`);
}
/**
 * Read component dependencies from dependencies.json if it exists
 */
function getComponentDependencies(component) {
    try {
        const templateDir = getTemplateDir(component);
        const dependencyFile = path_1.default.join(templateDir, 'dependencies.json');
        if (fs_extra_1.default.existsSync(dependencyFile)) {
            const dependencyData = fs_extra_1.default.readJSONSync(dependencyFile);
            return dependencyData.dependencies || [];
        }
        return [];
    }
    catch (error) {
        console.warn(chalk_1.default.yellow('!'), `Failed to read dependencies for component '${component}':`, error instanceof Error ? error.message : String(error));
        return [];
    }
}
/**
 * Resolve all dependencies for a component and its nested dependencies
 */
function resolveComponentDependencies(components, resolvedDeps = new Set(), processing = new Set()) {
    for (const component of components) {
        // Skip if already resolved or currently processing (circular dependency)
        if (resolvedDeps.has(component) || processing.has(component)) {
            continue;
        }
        // Add to processing set to detect circular dependencies
        processing.add(component);
        // Add the component itself
        resolvedDeps.add(component);
        // Get and process dependencies recursively
        try {
            const dependencies = getComponentDependencies(component);
            resolveComponentDependencies(dependencies, resolvedDeps, processing);
        }
        catch (error) {
            // If a template doesn't exist, that's fine, just skip its dependencies
            console.warn(chalk_1.default.yellow('!'), `Skipping dependencies for component '${component}':`, error instanceof Error ? error.message : String(error));
        }
        // Remove from processing set
        processing.delete(component);
    }
    return Array.from(resolvedDeps);
}
/**
 * Copy a component template to the user's project
 */
function copyComponentTemplate(component_1, targetDir_1) {
    return __awaiter(this, arguments, void 0, function* (component, targetDir, options = {}) {
        const { overwrite = false } = options;
        const config = yield (0, config_1.readConfig)();
        const templateDir = getTemplateDir(component);
        const destinationDir = path_1.default.resolve(process.cwd(), targetDir, component);
        // Check if component already exists
        if (fs_extra_1.default.existsSync(destinationDir) && !overwrite) {
            console.warn(chalk_1.default.yellow('!'), `Component '${component}' already exists. Use --overwrite to replace it.`);
            return false;
        }
        try {
            // Create the destination directory
            yield fs_extra_1.default.ensureDir(destinationDir);
            // Copy all files from the template
            const files = yield fs_extra_1.default.readdir(templateDir);
            for (const file of files) {
                // Skip dependencies.json as it's just for the CLI
                if (file === 'dependencies.json') {
                    continue;
                }
                const sourcePath = path_1.default.join(templateDir, file);
                const destPath = path_1.default.join(destinationDir, file);
                let content = yield fs_extra_1.default.readFile(sourcePath, 'utf-8');
                // Process the file content based on config
                content = processTemplateContent(content, config);
                yield fs_extra_1.default.writeFile(destPath, content);
            }
            console.log(chalk_1.default.green('✓'), `Added component '${component}'`);
            return true;
        }
        catch (error) {
            console.error(chalk_1.default.red('✗'), `Failed to copy component '${component}':`, error instanceof Error ? error.message : String(error));
            return false;
        }
    });
}
/**
 * Process template content based on configuration
 */
function processTemplateContent(content, config) {
    // Strip out TypeScript directives - remove the first 3 lines if they're the directive comments
    const lines = content.split(/\r?\n/);
    if (lines.length >= 3 &&
        lines[0].trim() === '/* tslint:disable */' &&
        lines[1].trim() === '/* eslint-disable */' &&
        lines[2].trim().startsWith('// @ts-nocheck')) {
        content = lines.slice(3).join('\n');
    }
    // Replace import paths based on styling approach
    if (config.styling === 'stylesheet') {
        // Use StyleSheet imports
        content = content.replace(/useNativeStyleSheet\s*=\s*false/g, 'useNativeStyleSheet = true');
    }
    // Replace theme configuration
    if (config.theme.useExisting && config.theme.existingThemePath) {
        // Use existing theme provider
        content = content.replace(/import.*from\s*["']@nativecn\/core["']/g, `import { cn, getVariantStyles, ThemeMode } from "@nativecn/core";\nimport { useTheme } from "${config.theme.existingThemePath}";`);
    }
    return content;
}
/**
 * Generate an index.ts barrel file that exports all components
 */
function generateComponentIndex(targetDir) {
    return __awaiter(this, void 0, void 0, function* () {
        try {
            const componentsDir = path_1.default.resolve(process.cwd(), targetDir);
            const dirs = yield fs_extra_1.default.readdir(componentsDir, { withFileTypes: true });
            // Filter for directories only
            const componentDirs = dirs.filter(dirent => dirent.isDirectory()).map(dirent => dirent.name);
            if (componentDirs.length === 0) {
                return;
            }
            // Generate export statements for each component
            const exports = componentDirs.map(dir => `export * from './${dir}';`).join('\n');
            const indexContent = `// This file is auto-generated by NativeCN CLI
// Do not edit this file manually

${exports}
`;
            const indexPath = path_1.default.join(componentsDir, 'index.ts');
            yield fs_extra_1.default.writeFile(indexPath, indexContent);
            console.log(chalk_1.default.green('✓'), `Updated index.ts with ${componentDirs.length} components`);
        }
        catch (error) {
            console.error(chalk_1.default.red('✗'), 'Failed to generate index.ts:', error instanceof Error ? error.message : String(error));
        }
    });
}
